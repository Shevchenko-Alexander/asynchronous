<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Active Object</title><link rel="stylesheet" href="boostbook.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"><link rel="home" href="index.html" title="Boost Asynchronous"><link rel="up" href="ch01.html" title="Chapter&nbsp;1.&nbsp;Related designs: std::async, Active Object, Proactor"><link rel="prev" href="ch01s02.html" title="N3558 / N3650"><link rel="next" href="ch01s04.html" title="Proactor"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Active Object</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch01s02.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;1.&nbsp;Related designs: std::async, Active Object, Proactor</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch01s04.html">Next</a></td></tr></table><hr></div><div class="sect1" title="Active Object"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e205"></a>Active Object</h2></div><div><h3 class="subtitle">Design</h3></div></div></div><p><span class="inlinemediaobject"><img src="../pics/ActiveObject.jpg"></span></p><p>This simplified diagram shows a possible design variation of an Active Object
                    pattern.</p><p>A thread-unsafe Servant is hidden behind a Proxy, which offers the same
                    members as the Servant itself. This Proxy is called by clients and delivers a
                    future object, which will, at some later point, contain the result of the
                    corresponding member called on the servant. The Proxy packs a MethodRequest
                    corresponding to a Servant call into the ActivationQueue. The Scheduler waits
                    permanently for MethodRequests in the queue, dequeues them, and executes them.
                    As only one scheduler waits for requests, it serializes access to the Servant,
                    thus providing thread-safety.</p><p>However, this pattern presents some liabilities:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Performance overhead: depending on the system, data moving and
                                context switching can be a performance drain.</p></li><li class="listitem"><p>Memory overhead: for every Servant, a thread has to be created,
                                consuming resources.</p></li><li class="listitem"><p>Usage: getting a future doesn't bring as much asynchronous
                                behaviour as one might think. Usually, docs tell you to do something
                                else and check it later. But most cases simply mean that the client
                                will earlier or later block until the future is ready. This also
                                applies to std/boost::async.</p></li></ul></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch01s02.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch01.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch01s04.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">N3558 / N3650&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Proactor</td></tr></table></div></body></html>