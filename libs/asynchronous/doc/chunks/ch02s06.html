<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Diagnostics</title><link rel="stylesheet" href="boostbook.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"><link rel="home" href="index.html" title="Boost Asynchronous"><link rel="up" href="ch02.html" title="Chapter&nbsp;2.&nbsp;Features"><link rel="prev" href="ch02s05.html" title="Interrupting"><link rel="next" href="ch02s07.html" title="Continuations"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Diagnostics</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02s05.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;2.&nbsp;Features</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch02s07.html">Next</a></td></tr></table><hr></div><div class="sect1" title="Diagnostics"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e313"></a>Diagnostics</h2></div></div></div><p>Finding out how good your software is doing is not an easy task. You need to
                    add lots of logging to find out which function call takes too long and becomes a
                    bottleneck. Finding out the minimum required hardware to run your application is
                    even harder.</p><p>Asynchronous design helps here too. By logging the required time and the
                    frequency of tasks, it is easy to find out how many cores are needed.
                    Bottlenecks can be found by logging what the Active Component is doing and how
                    long. Finally, designing the asynchronous Active Component as state machines and
                    logging state changes will allow a better understanding of your system and make
                    visible potential for concurrency. Even for non-parallel algorithms, finding
                    out, using a state machine, the earliest point a task can be thrown to a
                    threadpool will give some sort of low-hanging-fruit concurrency. Throw enough
                    tasks to the threadpool and manage this with a state machine and you might use
                    your cores with little effort. Parallelization can then be used later on by
                    logging which tasks are worth parallelized.</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02s05.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch02.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch02s07.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Interrupting&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Continuations</td></tr></table></div></body></html>